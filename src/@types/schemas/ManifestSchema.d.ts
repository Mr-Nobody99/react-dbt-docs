declare namespace Dbt_Manifest {
  /* tslint:disable */
  /**
   * This file was automatically generated by json-schema-to-typescript.
   * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
   * and run json-schema-to-typescript to regenerate this file.
   */

  /**
   * WritableManifest(metadata: dbt.contracts.graph.manifest.ManifestMetadata, nodes: Mapping[str, Union[dbt.contracts.graph.compiled.CompiledAnalysisNode, dbt.contracts.graph.compiled.CompiledDataTestNode, dbt.contracts.graph.compiled.CompiledModelNode, dbt.contracts.graph.compiled.CompiledHookNode, dbt.contracts.graph.compiled.CompiledRPCNode, dbt.contracts.graph.compiled.CompiledSchemaTestNode, dbt.contracts.graph.compiled.CompiledSeedNode, dbt.contracts.graph.compiled.CompiledSnapshotNode, dbt.contracts.graph.parsed.ParsedAnalysisNode, dbt.contracts.graph.parsed.ParsedDataTestNode, dbt.contracts.graph.parsed.ParsedHookNode, dbt.contracts.graph.parsed.ParsedModelNode, dbt.contracts.graph.parsed.ParsedRPCNode, dbt.contracts.graph.parsed.ParsedSchemaTestNode, dbt.contracts.graph.parsed.ParsedSeedNode, dbt.contracts.graph.parsed.ParsedSnapshotNode]], sources: Mapping[str, dbt.contracts.graph.parsed.ParsedSourceDefinition], macros: Mapping[str, dbt.contracts.graph.parsed.ParsedMacro], docs: Mapping[str, dbt.contracts.graph.parsed.ParsedDocumentation], exposures: Mapping[str, dbt.contracts.graph.parsed.ParsedExposure], selectors: Mapping[str, Any], disabled: Union[List[Union[dbt.contracts.graph.compiled.CompiledAnalysisNode, dbt.contracts.graph.compiled.CompiledDataTestNode, dbt.contracts.graph.compiled.CompiledModelNode, dbt.contracts.graph.compiled.CompiledHookNode, dbt.contracts.graph.compiled.CompiledRPCNode, dbt.contracts.graph.compiled.CompiledSchemaTestNode, dbt.contracts.graph.compiled.CompiledSeedNode, dbt.contracts.graph.compiled.CompiledSnapshotNode, dbt.contracts.graph.parsed.ParsedAnalysisNode, dbt.contracts.graph.parsed.ParsedDataTestNode, dbt.contracts.graph.parsed.ParsedHookNode, dbt.contracts.graph.parsed.ParsedModelNode, dbt.contracts.graph.parsed.ParsedRPCNode, dbt.contracts.graph.parsed.ParsedSchemaTestNode, dbt.contracts.graph.parsed.ParsedSeedNode, dbt.contracts.graph.parsed.ParsedSnapshotNode, dbt.contracts.graph.parsed.ParsedSourceDefinition]], NoneType], parent_map: Union[Dict[str, List[str]], NoneType], child_map: Union[Dict[str, List[str]], NoneType])
   */
  interface ManifestSchema {
    /**
     * Metadata about the manifest
     */
    metadata: {
      dbt_schema_version?: string;
      dbt_version?: string;
      generated_at?: string;
      invocation_id?: string | null;
      env?: {
        [k: string]: string;
      };
      /**
       * A unique identifier for the project
       */
      project_id?: string | null;
      /**
       * A unique identifier for the user
       */
      user_id?: string | null;
      /**
       * Whether dbt is configured to send anonymous usage statistics
       */
      send_anonymous_usage_stats?: boolean | null;
      /**
       * The type name of the adapter
       */
      adapter_type?: string | null;
    };
    /**
     * The nodes defined in the dbt project and its dependencies
     */
    nodes: {
      [k: string]:
        | CompiledAnalysisNode
        | CompiledDataTestNode
        | CompiledModelNode
        | CompiledHookNode
        | CompiledRPCNode
        | CompiledSchemaTestNode
        | CompiledSeedNode
        | CompiledSnapshotNode
        | ParsedAnalysisNode
        | ParsedDataTestNode
        | ParsedHookNode
        | ParsedModelNode
        | ParsedRPCNode
        | ParsedSchemaTestNode
        | ParsedSeedNode
        | ParsedSnapshotNode;
    };
    /**
     * The sources defined in the dbt project and its dependencies
     */
    sources: {
      [k: string]: ParsedSourceDefinition;
    };
    /**
     * The macros defined in the dbt project and its dependencies
     */
    macros: {
      [k: string]: ParsedMacro;
    };
    /**
     * The docs defined in the dbt project and its dependencies
     */
    docs: {
      [k: string]: ParsedDocumentation;
    };
    /**
     * The exposures defined in the dbt project and its dependencies
     */
    exposures: {
      [k: string]: ParsedExposure;
    };
    /**
     * The selectors defined in selectors.yml
     */
    selectors: {
      [k: string]: unknown;
    };
    /**
     * A list of the disabled nodes in the target
     */
    disabled?:
      | (
          | CompiledAnalysisNode
          | CompiledDataTestNode
          | CompiledModelNode
          | CompiledHookNode
          | CompiledRPCNode
          | CompiledSchemaTestNode
          | CompiledSeedNode
          | CompiledSnapshotNode
          | ParsedAnalysisNode
          | ParsedDataTestNode
          | ParsedHookNode
          | ParsedModelNode
          | ParsedRPCNode
          | ParsedSchemaTestNode
          | ParsedSeedNode
          | ParsedSnapshotNode
          | ParsedSourceDefinition
        )[]
      | null;
    /**
     * A mapping fromÂ child nodes to their dependencies
     */
    parent_map?: {
      [k: string]: string[];
    } | null;
    /**
     * A mapping from parent nodes to their dependents
     */
    child_map?: {
      [k: string]: string[];
    } | null;
  }
  /**
   * CompiledAnalysisNode(raw_sql: str, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, compiled_sql: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
   */
  interface CompiledAnalysisNode {
    raw_sql: string;
    compiled: boolean;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "analysis";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    compiled_sql?: string | null;
    extra_ctes_injected?: boolean;
    extra_ctes?: InjectedCTE[];
    relation_name?: string | null;
  }
  /**
   * FileHash(name: str, checksum: str)
   */
  interface FileHash {
    name: string;
    checksum: string;
  }
  /**
   * Hook(sql: str, transaction: bool = True, index: Union[int, NoneType] = None)
   */
  interface Hook {
    sql: string;
    transaction?: boolean;
    index?: number | null;
  }
  /**
   * ColumnInfo(name: str, description: str = '', meta: Dict[str, Any] = <factory>, data_type: Union[str, NoneType] = None, quote: Union[bool, NoneType] = None, tags: List[str] = <factory>, _extra: Dict[str, Any] = <factory>)
   */
  interface ColumnInfo {
    name: string;
    description?: string;
    meta?: {
      [k: string]: unknown;
    };
    data_type?: string | null;
    quote?: boolean | null;
    tags?: string[];
    [k: string]: unknown;
  }
  /**
   * InjectedCTE(id: str, sql: str)
   */
  interface InjectedCTE {
    id: string;
    sql: string;
  }
  /**
   * CompiledDataTestNode(raw_sql: str, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, compiled_sql: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
   */
  interface CompiledDataTestNode {
    raw_sql: string;
    compiled: boolean;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "test";
    alias: string;
    checksum: FileHash;
    /**
     * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'test', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None, severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      severity?: string;
      store_failures?: boolean | null;
      where?: string | null;
      limit?: number | null;
      fail_calc?: string;
      warn_if?: string;
      error_if?: string;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    compiled_sql?: string | null;
    extra_ctes_injected?: boolean;
    extra_ctes?: InjectedCTE[];
    relation_name?: string | null;
  }
  /**
   * CompiledModelNode(raw_sql: str, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, compiled_sql: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
   */
  interface CompiledModelNode {
    raw_sql: string;
    compiled: boolean;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "model";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    compiled_sql?: string | null;
    extra_ctes_injected?: boolean;
    extra_ctes?: InjectedCTE[];
    relation_name?: string | null;
  }
  /**
   * CompiledHookNode(raw_sql: str, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, compiled_sql: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None, index: Union[int, NoneType] = None)
   */
  interface CompiledHookNode {
    raw_sql: string;
    compiled: boolean;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "operation";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    compiled_sql?: string | null;
    extra_ctes_injected?: boolean;
    extra_ctes?: InjectedCTE[];
    relation_name?: string | null;
    index?: number | null;
  }
  /**
   * CompiledRPCNode(raw_sql: str, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, compiled_sql: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
   */
  interface CompiledRPCNode {
    raw_sql: string;
    compiled: boolean;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "rpc";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    compiled_sql?: string | null;
    extra_ctes_injected?: boolean;
    extra_ctes?: InjectedCTE[];
    relation_name?: string | null;
  }
  /**
   * CompiledSchemaTestNode(raw_sql: str, test_metadata: dbt.contracts.graph.parsed.TestMetadata, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, compiled_sql: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None, column_name: Union[str, NoneType] = None)
   */
  interface CompiledSchemaTestNode {
    raw_sql: string;
    test_metadata: TestMetadata;
    compiled: boolean;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "test";
    alias: string;
    checksum: FileHash;
    /**
     * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'test', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None, severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      severity?: string;
      store_failures?: boolean | null;
      where?: string | null;
      limit?: number | null;
      fail_calc?: string;
      warn_if?: string;
      error_if?: string;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    compiled_sql?: string | null;
    extra_ctes_injected?: boolean;
    extra_ctes?: InjectedCTE[];
    relation_name?: string | null;
    column_name?: string | null;
  }
  /**
   * TestMetadata(name: str, kwargs: Dict[str, Any] = <factory>, namespace: Union[str, NoneType] = None)
   */
  interface TestMetadata {
    name: string;
    kwargs?: {
      [k: string]: unknown;
    };
    namespace?: string | null;
  }
  /**
   * CompiledSeedNode(raw_sql: str, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.SeedConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, compiled_sql: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
   */
  interface CompiledSeedNode {
    raw_sql: string;
    compiled: boolean;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "seed";
    alias: string;
    checksum: FileHash;
    /**
     * SeedConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'seed', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None, quote_columns: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      quote_columns?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    compiled_sql?: string | null;
    extra_ctes_injected?: boolean;
    extra_ctes?: InjectedCTE[];
    relation_name?: string | null;
  }
  /**
   * CompiledSnapshotNode(raw_sql: str, compiled: bool, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, compiled_sql: Union[str, NoneType] = None, extra_ctes_injected: bool = False, extra_ctes: List[dbt.contracts.graph.compiled.InjectedCTE] = <factory>, relation_name: Union[str, NoneType] = None, _pre_injected_sql: Union[str, NoneType] = None)
   */
  interface CompiledSnapshotNode {
    raw_sql: string;
    compiled: boolean;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "snapshot";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    compiled_sql?: string | null;
    extra_ctes_injected?: boolean;
    extra_ctes?: InjectedCTE[];
    relation_name?: string | null;
  }
  /**
   * ParsedAnalysisNode(raw_sql: str, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>)
   */
  interface ParsedAnalysisNode {
    raw_sql: string;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "analysis";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
  }
  /**
   * ParsedDataTestNode(raw_sql: str, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>)
   */
  interface ParsedDataTestNode {
    raw_sql: string;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "test";
    alias: string;
    checksum: FileHash;
    /**
     * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'test', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None, severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      severity?: string;
      store_failures?: boolean | null;
      where?: string | null;
      limit?: number | null;
      fail_calc?: string;
      warn_if?: string;
      error_if?: string;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
  }
  /**
   * ParsedHookNode(raw_sql: str, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, index: Union[int, NoneType] = None)
   */
  interface ParsedHookNode {
    raw_sql: string;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "operation";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    index?: number | null;
  }
  /**
   * ParsedModelNode(raw_sql: str, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>)
   */
  interface ParsedModelNode {
    raw_sql: string;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "model";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
  }
  /**
   * ParsedRPCNode(raw_sql: str, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.NodeConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>)
   */
  interface ParsedRPCNode {
    raw_sql: string;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "rpc";
    alias: string;
    checksum: FileHash;
    /**
     * NodeConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'view', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
  }
  /**
   * ParsedSchemaTestNode(raw_sql: str, test_metadata: dbt.contracts.graph.parsed.TestMetadata, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.TestConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>, column_name: Union[str, NoneType] = None)
   */
  interface ParsedSchemaTestNode {
    raw_sql: string;
    test_metadata: TestMetadata;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "test";
    alias: string;
    checksum: FileHash;
    /**
     * TestConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'test', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = 'dbt_test__audit', database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None, severity: dbt.contracts.graph.model_config.Severity = 'ERROR', store_failures: Union[bool, NoneType] = None, where: Union[str, NoneType] = None, limit: Union[int, NoneType] = None, fail_calc: str = 'count(*)', warn_if: str = '!= 0', error_if: str = '!= 0')
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      severity?: string;
      store_failures?: boolean | null;
      where?: string | null;
      limit?: number | null;
      fail_calc?: string;
      warn_if?: string;
      error_if?: string;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
    column_name?: string | null;
  }
  /**
   * ParsedSeedNode(raw_sql: str, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.SeedConfig = <factory>, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>)
   */
  interface ParsedSeedNode {
    raw_sql: string;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "seed";
    alias: string;
    checksum: FileHash;
    /**
     * SeedConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'seed', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None, quote_columns: Union[bool, NoneType] = None)
     */
    config?: {
      enabled?: boolean;
      materialized?: string;
      persist_docs?: {
        [k: string]: unknown;
      };
      "post-hook"?: Hook[];
      "pre-hook"?: Hook[];
      vars?: {
        [k: string]: unknown;
      };
      quoting?: {
        [k: string]: unknown;
      };
      column_types?: {
        [k: string]: unknown;
      };
      alias?: string | null;
      schema?: string | null;
      database?: string | null;
      tags?: string[] | string;
      full_refresh?: boolean | null;
      quote_columns?: boolean | null;
      [k: string]: unknown;
    };
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
  }
  /**
   * ParsedSnapshotNode(raw_sql: str, database: Union[str, NoneType], schema: str, fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, resource_type: dbt.node_types.NodeType, alias: str, checksum: dbt.contracts.files.FileHash, config: dbt.contracts.graph.model_config.SnapshotConfig, tags: List[str] = <factory>, refs: List[List[str]] = <factory>, sources: List[List[Any]] = <factory>, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, compiled_path: Union[str, NoneType] = None, build_path: Union[str, NoneType] = None, deferred: bool = False, unrendered_config: Dict[str, Any] = <factory>, created_at: int = <factory>)
   */
  interface ParsedSnapshotNode {
    raw_sql: string;
    database?: string | null;
    schema: string;
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    resource_type: "snapshot";
    alias: string;
    checksum: FileHash;
    config: SnapshotConfig;
    tags?: string[];
    refs?: string[][];
    sources?: unknown[][];
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    compiled_path?: string | null;
    build_path?: string | null;
    deferred?: boolean;
    unrendered_config?: {
      [k: string]: unknown;
    };
    created_at?: number;
  }
  /**
   * SnapshotConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True, materialized: str = 'snapshot', persist_docs: Dict[str, Any] = <factory>, post_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, pre_hook: List[dbt.contracts.graph.model_config.Hook] = <factory>, vars: Dict[str, Any] = <factory>, quoting: Dict[str, Any] = <factory>, column_types: Dict[str, Any] = <factory>, alias: Union[str, NoneType] = None, schema: Union[str, NoneType] = None, database: Union[str, NoneType] = None, tags: Union[List[str], str] = <factory>, full_refresh: Union[bool, NoneType] = None, strategy: Union[str, NoneType] = None, unique_key: Union[str, NoneType] = None, target_schema: Union[str, NoneType] = None, target_database: Union[str, NoneType] = None, updated_at: Union[str, NoneType] = None, check_cols: Union[str, List[str], NoneType] = None)
   */
  interface SnapshotConfig {
    enabled?: boolean;
    materialized?: string;
    persist_docs?: {
      [k: string]: unknown;
    };
    "post-hook"?: Hook[];
    "pre-hook"?: Hook[];
    vars?: {
      [k: string]: unknown;
    };
    quoting?: {
      [k: string]: unknown;
    };
    column_types?: {
      [k: string]: unknown;
    };
    alias?: string | null;
    schema?: string | null;
    database?: string | null;
    tags?: string[] | string;
    full_refresh?: boolean | null;
    strategy?: string | null;
    unique_key?: string | null;
    target_schema?: string | null;
    target_database?: string | null;
    updated_at?: string | null;
    check_cols?: string | string[] | null;
    [k: string]: unknown;
  }
  /**
   * ParsedSourceDefinition(fqn: List[str], database: Union[str, NoneType], schema: str, unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, source_name: str, source_description: str, loader: str, identifier: str, resource_type: dbt.node_types.NodeType, quoting: dbt.contracts.graph.unparsed.Quoting = <factory>, loaded_at_field: Union[str, NoneType] = None, freshness: Union[dbt.contracts.graph.unparsed.FreshnessThreshold, NoneType] = None, external: Union[dbt.contracts.graph.unparsed.ExternalTable, NoneType] = None, description: str = '', columns: Dict[str, dbt.contracts.graph.parsed.ColumnInfo] = <factory>, meta: Dict[str, Any] = <factory>, source_meta: Dict[str, Any] = <factory>, tags: List[str] = <factory>, config: dbt.contracts.graph.model_config.SourceConfig = <factory>, patch_path: Union[pathlib.Path, NoneType] = None, unrendered_config: Dict[str, Any] = <factory>, relation_name: Union[str, NoneType] = None, created_at: int = <factory>)
   */
  interface ParsedSourceDefinition {
    fqn: string[];
    database?: string | null;
    schema: string;
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    source_name: string;
    source_description: string;
    loader: string;
    identifier: string;
    resource_type: "source";
    /**
     * Quoting(database: Union[bool, NoneType] = None, schema: Union[bool, NoneType] = None, identifier: Union[bool, NoneType] = None, column: Union[bool, NoneType] = None)
     */
    quoting?: {
      database?: boolean | null;
      schema?: boolean | null;
      identifier?: boolean | null;
      column?: boolean | null;
    };
    loaded_at_field?: string | null;
    freshness?: FreshnessThreshold | null;
    external?: ExternalTable | null;
    description?: string;
    columns?: {
      [k: string]: ColumnInfo;
    };
    meta?: {
      [k: string]: unknown;
    };
    source_meta?: {
      [k: string]: unknown;
    };
    tags?: string[];
    /**
     * SourceConfig(_extra: Dict[str, Any] = <factory>, enabled: bool = True)
     */
    config?: {
      enabled?: boolean;
      [k: string]: unknown;
    };
    patch_path?: string | null;
    unrendered_config?: {
      [k: string]: unknown;
    };
    relation_name?: string | null;
    created_at?: number;
  }
  /**
   * FreshnessThreshold(warn_after: Union[dbt.contracts.graph.unparsed.Time, NoneType] = None, error_after: Union[dbt.contracts.graph.unparsed.Time, NoneType] = None, filter: Union[str, NoneType] = None)
   */
  interface FreshnessThreshold {
    warn_after?: Time | null;
    error_after?: Time | null;
    filter?: string | null;
  }
  /**
   * Time(count: int, period: dbt.contracts.graph.unparsed.TimePeriod)
   */
  interface Time {
    count: number;
    period: "minute" | "hour" | "day";
  }
  /**
   * ExternalTable(_extra: Dict[str, Any] = <factory>, location: Union[str, NoneType] = None, file_format: Union[str, NoneType] = None, row_format: Union[str, NoneType] = None, tbl_properties: Union[str, NoneType] = None, partitions: Union[List[dbt.contracts.graph.unparsed.ExternalPartition], NoneType] = None)
   */
  interface ExternalTable {
    location?: string | null;
    file_format?: string | null;
    row_format?: string | null;
    tbl_properties?: string | null;
    partitions?: ExternalPartition[] | null;
    [k: string]: unknown;
  }
  /**
   * ExternalPartition(_extra: Dict[str, Any] = <factory>, name: str = '', description: str = '', data_type: str = '', meta: Dict[str, Any] = <factory>)
   */
  interface ExternalPartition {
    name?: string;
    description?: string;
    data_type?: string;
    meta?: {
      [k: string]: unknown;
    };
    [k: string]: unknown;
  }
  /**
   * ParsedMacro(unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, macro_sql: str, resource_type: dbt.node_types.NodeType, tags: List[str] = <factory>, depends_on: dbt.contracts.graph.parsed.MacroDependsOn = <factory>, description: str = '', meta: Dict[str, Any] = <factory>, docs: dbt.contracts.graph.unparsed.Docs = <factory>, patch_path: Union[str, NoneType] = None, arguments: List[dbt.contracts.graph.unparsed.MacroArgument] = <factory>, created_at: int = <factory>)
   */
  interface ParsedMacro {
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    macro_sql: string;
    resource_type: "macro";
    tags?: string[];
    /**
     * MacroDependsOn(macros: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
    };
    description?: string;
    meta?: {
      [k: string]: unknown;
    };
    /**
     * Docs(show: bool = True)
     */
    docs?: {
      show?: boolean;
    };
    patch_path?: string | null;
    arguments?: MacroArgument[];
    created_at?: number;
  }
  /**
   * MacroArgument(name: str, type: Union[str, NoneType] = None, description: str = '')
   */
  interface MacroArgument {
    name: string;
    type?: string | null;
    description?: string;
  }
  /**
   * ParsedDocumentation(unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, block_contents: str)
   */
  interface ParsedDocumentation {
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    block_contents: string;
  }
  /**
   * ParsedExposure(fqn: List[str], unique_id: str, package_name: str, root_path: str, path: str, original_file_path: str, name: str, type: dbt.contracts.graph.unparsed.ExposureType, owner: dbt.contracts.graph.unparsed.ExposureOwner, resource_type: dbt.node_types.NodeType = <NodeType.Exposure: 'exposure'>, description: str = '', maturity: Union[dbt.contracts.graph.unparsed.MaturityType, NoneType] = None, meta: Dict[str, Any] = <factory>, tags: List[str] = <factory>, url: Union[str, NoneType] = None, depends_on: dbt.contracts.graph.parsed.DependsOn = <factory>, refs: List[List[str]] = <factory>, sources: List[List[str]] = <factory>, created_at: int = <factory>)
   */
  interface ParsedExposure {
    fqn: string[];
    unique_id: string;
    package_name: string;
    root_path: string;
    path: string;
    original_file_path: string;
    name: string;
    type: "dashboard" | "notebook" | "analysis" | "ml" | "application";
    owner: ExposureOwner;
    resource_type?:
      | "model"
      | "analysis"
      | "test"
      | "snapshot"
      | "operation"
      | "seed"
      | "rpc"
      | "docs"
      | "source"
      | "macro"
      | "exposure";
    description?: string;
    maturity?: ("low" | "medium" | "high") | null;
    meta?: {
      [k: string]: unknown;
    };
    tags?: string[];
    url?: string | null;
    /**
     * DependsOn(macros: List[str] = <factory>, nodes: List[str] = <factory>)
     */
    depends_on?: {
      macros?: string[];
      nodes?: string[];
    };
    refs?: string[][];
    sources?: string[][];
    created_at?: number;
  }
  /**
   * ExposureOwner(email: str, name: Union[str, NoneType] = None)
   */
  interface ExposureOwner {
    email: string;
    name?: string | null;
  }
}
